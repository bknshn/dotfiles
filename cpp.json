{
    "Boruvka.cpp": {
        "prefix": "Boruvka",
        "body": "// F(現在の木の個数, vector<頂点->集合のindex>) -> vector<集合のindex->(cost, to)>\n// 使い方: https://codeforces.com/contest/1242/submission/64467604\ntemplate <class T, class F>\nT boruvka(int n, const F& f) {\n    struct UnionFind {\n        vector<int> number;  // 0以上のとき親のindex, 負のときは集合サイズ\n        UnionFind(int n) : number(n, -1) {}\n        int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n        bool unite(int x, int y) {\n            x = root(x), y = root(y);\n            if (x == y) return false;\n            if (number[y] < number[x]) swap(x, y);\n            number[x] += number[y];\n            number[y] = x;\n            return true;\n        }\n    };\n\n    UnionFind uf(n);\n    T res(0);\n    bool update = true;\n    vector<int> belongs(n), rev(n);\n    while (update) {\n        update = false;\n        int ptr = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == uf.root(i)) rev[ptr] = i, belongs[i] = ptr++;\n        }\n        for (int i = 0; i < n; i++) belongs[i] = belongs[uf.root(i)];\n        vector<pair<T, int>> v = f(ptr, belongs);\n        for (int i = 0; i < ptr; i++) {\n            if (v[i].second >= 0 && uf.unite(rev[i], rev[v[i].second])) res += v[i].first, update = true;\n        }\n        if (!update) break;\n    }\n    return res;\n}\n",
        "description": "Boruvka"
    },
    "Dijkstra.cpp": {
        "prefix": "Dijkstra",
        "body": "class UndirectedGraph {\n    struct Edge {\n        int to, cost;\n    };\n\npublic:\n    vector<vector<Edge>> G;\n    int V;\n    UndirectedGraph(int V) : G(V), V(V) {}\n    void add_edge(int u, int v, int cost) {\n        G[u].push_back({v, cost});\n        G[v].push_back({u, cost});\n    }\n    vector<int> dijkstra(int s) {\n        vector<int> d(V, 1e18);\n        d[s] = 0;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;  // {dist, v}\n        que.push({0, s});\n        while (!que.empty()) {\n            pair<int, int> p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;  // 定数倍枝刈り\n            for (Edge e : G[v]) {\n                int tmp = d[v] + e.cost;\n                if (d[e.to] <= tmp) continue;\n                d[e.to] = tmp;\n                que.push({tmp, e.to});\n            }\n        }\n        return d;\n    }\n};\n",
        "description": "Dijkstra"
    },
    "AbstractDijkstra.cpp": {
        "prefix": "AbstractDijkstra",
        "body": "template <class T>\nstruct Graph {\n    struct Edge {\n        int to;\n        T cost;\n    };\n    vector<vector<Edge>> g;\n    int n;\n    bool is_directed;\n    Graph(int n_, bool is_directed_ = true) : g(n_), n(n_), is_directed(is_directed_) {}\n    void add_edge(int u, int v, T cost) {\n        g[u].emplace_back(v, cost);\n        if (!is_directed) g[v].emplace_back(u, cost);\n    }\n    vector<T> dijkstra(int s) {\n        // constexpr T INF = numeric_limits<T>::max() / 10;\n        // constexpr T ZERO = 0;\n        constexpr T INF = {1e18, 1e18};\n        constexpr T ZERO = {0, 0};\n        // 上2つは型によって書き換える必要あり\n        vector<T> d(n, INF);\n        d[0] = ZERO;\n        using T_i = pair<T, int>;  // {dist, v}\n        priority_queue<T_i, vector<T_i>, greater<T_i>> q;\n        q.push({d[0], s});\n        while (!q.empty()) {\n            T_i p = q.top();\n            q.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;  // 定数倍枝刈り\n            for (Edge e : g[v]) {\n                T nxt = d[v] + e.cost;\n                if (d[e.to] <= nxt) continue;\n                d[e.to] = nxt;\n                q.emplace(nxt, e.to);\n            }\n        }\n        return d;\n    }\n};\n",
        "description": "AbstractDijkstra"
    },
    "WarshallFloyd.cpp": {
        "prefix": "WarshallFloyd",
        "body": "template <class T>\nvoid warshall_floyd(vector<vector<T>> &d) {\n    int n = d.size();\n    for (int i = 0; i < n; i++) assert(d[i][i] == 0);\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n",
        "description": "WarshallFloyd"
    },
    "Kruskal.cpp": {
        "prefix": "Kruskal",
        "body": "class UnionFind {\npublic:\n    VI par, rank;\n    UnionFind(int n) {\n        par = VI(n);\n        iota(par.begin(), par.end(), 0);\n        rank = VI(n, 0);\n    }\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = root(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return;\n        }\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n};\n\nstruct edge {\n    int u, v, cost;\n};\nbool comp(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint kruskal(int V, vector<edge>& es) {\n    sort(es.begin(), es.end(), comp);\n    UnionFind uf(V);\n    int ans = 0;\n    for (edge e : es) {\n        if (uf.same(e.u, e.v)) {\n            continue;\n        }\n        uf.unite(e.u, e.v);\n        ans += e.cost;\n    }\n    return ans;\n}\nsigned main() {\n    int V, E;\n    cin >> V >> E;\n    vector<edge> es(E);\n    REP(i, E) { cin >> es[i].u >> es[i].v >> es[i].cost; }\n    cout << kruskal(V, es) << endl;\n}\n",
        "description": "Kruskal"
    },
    "LowestCommonAncestor.cpp": {
        "prefix": "LowestCommonAncestor",
        "body": "// edgeを貼ったあとにbuild()を忘れない！\nstruct TreeDoubling {\n    struct Edge {\n        int to, color, len;\n    };  // 場合に応じて書き換える、toは必須\n    vector<vector<Edge>> g;\n    int n, size;  // MSB + 1\n    int root;\n    vector<int> depth;\n    vector<vector<int>> parent;  // ダミー頂点n(親もn)\n    TreeDoubling(int n) : g(n), n(n), depth(n), size(64 - __builtin_clzll(n)) {\n        parent.resize(size, vector<int>(n + 1, n));\n    }\n    void dfs(int v, int prev, int d) {\n        depth[v] = d;\n        parent[0][v] = prev;\n        for (auto& s : g[v])\n            if (s.to != prev) {\n                dfs(s.to, v, d + 1);\n            }\n    }\n    void build(int root_ = 0) {\n        root = root_;\n        dfs(root, n, 0);\n        for (int k = 0; k < size - 1; k++) {\n            for (int i = 0; i < n; i++) {\n                parent[k + 1][i] = parent[k][parent[k][i]];\n            }\n        }\n    }\n\n    // vからd個分親にさかのぼった頂点、rootよりも上はnを返す\n    int query(int v, int d) {\n        int ret = v;\n        for (int j = 0; j < size; j++) {\n            if (d >> j & 1) ret = parent[j][ret];\n        }\n        return ret;\n    }\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        v = query(v, depth[v] - depth[u]);\n        if (u == v) return u;\n\n        for (int j = size - 1; j >= 0; j--) {\n            if (parent[j][u] == parent[j][v]) continue;\n            u = parent[j][u];\n            v = parent[j][v];\n        }\n        assert(parent[0][u] == parent[0][v]);\n        return parent[0][u];\n    }\n};\n",
        "description": "LowestCommonAncestor"
    },
    "BellmanFord.cpp": {
        "prefix": "BellmanFord",
        "body": "template <class T>\nstruct Edge {\n    int from, to;\n    T cost;\n};\n// O(EV)、負のサイクルを通った後に到達できる点についてはdist[v]=INFを返す\ntemplate <class T>\nvector<T> bellman_ford(vector<Edge<T>>& edges, int n, int s) {\n    constexpr T INF = 1e18;  // Tの型に応じて書き換える必要あり\n    vector<T> dist(n, INF);\n    dist[s] = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (Edge<T>& e : edges) {\n            if (dist[e.from] == INF) continue;\n            dist[e.to] = min(dist[e.to], dist[e.from] + e.cost);\n        }\n    }\n    for (Edge<T>& e : edges) {\n        // sから到達できる負のサイクル検出\n        if (dist[e.to] < INF && dist[e.from] + e.cost < dist[e.to]) {\n            dist[e.from] = -INF;\n            dist[e.to] = -INF;\n        }\n    }\n    for (int i = 0; i < n - 1; i++) {\n        for (Edge<T>& e : edges) {\n            if (dist[e.from] == -INF) dist[e.to] = -INF;\n        }\n    }\n    return dist;\n}\n",
        "description": "BellmanFord"
    },
    "GridGraph.cpp": {
        "prefix": "GridGraph",
        "body": "// 二次元Grid Graphの斜め方向の累積和\nclass GridGraph {\n    // queryを計算しやすいようにaccの範囲外の値も便宜的に定義\n    int acc_any(int i, int j) {\n        if (i + j < 0 || H + W - 1 <= i + j) return 0;\n        if (i < 0 || j >= W) return 0;\n        if (j < 0 && i + j < H) return acc[i + j][0];\n        if (i >= H && i + j >= H) return acc[H - 1][i + j - (H - 1)];\n        return acc[i][j];\n    }\n\npublic:\n    VVI t;\n    int H, W;\n    VVI acc;\n    GridGraph(VVI& tbl) : t(tbl), H(tbl.size()), W(tbl[0].size()) { set_acc(); }\n    VI& operator[](int i) { return t[i]; }\n    bool exist(int i, int j) { return 0 <= i && i < H && 0 <= j && j < W && t[i][j]; }\n    // 左下方向への累積和\n    void set_acc() {\n        acc = VVI(H, VI(W));\n        REP(i, H) {\n            REP(j, W) {\n                int before = (i == 0 || j == W - 1) ? 0 : acc[i - 1][j + 1];\n                acc[i][j] = before + t[i][j];\n            }\n        }\n    }\n    // 時計回りに90度回転\n    void rotate() {\n        VVI t2(W, VI(H));\n        REP(i, H) {\n            REP(j, W) { t2[j][H - i - 1] = t[i][j]; }\n        }\n        t = t2;\n        swap(H, W);\n        set_acc();\n    }\n    // [i0, i1)の斜めのsum\n    int query(int i0, int j0, int i1, int j1) {\n        assert(i0 + j0 == i1 + j1);\n        assert(i1 > i0);\n        return acc_any(i1 - 1, j1 + 1) - acc_any(i0 - 1, j0 + 1);\n    }\n};\n\nsigned main() {}\n",
        "description": "GridGraph"
    },
    "TreeDiameter.cpp": {
        "prefix": "TreeDiameter",
        "body": "// 木の直径がdiameterに格納される\nsigned main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    REP(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int diameter = 0;\n    function<int(int, int)> dfs = [&](int v, int p) {\n        int ma = 0;\n        for (int s : g[v])\n            if (s != p) {\n                int tmp = dfs(s, v) + 1;\n                diameter = max(diameter, ma + tmp);\n                ma = max(ma, tmp);\n            }\n        return ma;\n    };\n    dfs(0, -1);\n}\n",
        "description": "TreeDiameter"
    },
    "StronglyConnectedComponent.cpp": {
        "prefix": "StronglyConnectedComponent",
        "body": "class DirectedGraph {\n    vector<bool> used;\n    vector<int> vs;  // dfsでpost-orderの順に頂点を格納\n    void dfs(int v) {\n        used[v] = true;\n        for (int s : edge[v]) {\n            if (!used[s]) dfs(s);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k) {\n        cmp[v] = k;\n        for (int s : redge[v]) {\n            if (cmp[s] == -1) rdfs(s, k);\n        }\n    }\n\npublic:\n    int N;\n    vector<vector<int>> edge, redge;\n    vector<int> cmp;  // 強連結成分のインデックス(トポロジカル順序)\n    DirectedGraph(int n) {\n        N = n;\n        edge.resize(N);\n        redge.resize(N);\n    }\n    void add_edge(int from, int to) {\n        assert(0 <= from && from < N && 0 <= to && to < N);\n        edge[from].push_back(to);\n        redge[to].push_back(from);\n    }\n    // cmpに各頂点がトポロジカル順で何番目の強連結成分に入るかを格納し、強連結成分の個数を返す\n    // O(E + V)\n    int scc() {\n        used.assign(N, false);\n        vs.clear();\n        vs.reserve(N);\n        for (int v = 0; v < N; v++) {\n            if (!used[v]) dfs(v);\n        }\n        assert(vs.size() == N);\n        // dfsにおけるpost orderの番号が小さい順にrdfs\n        // 同じ強連結成分に属するものはredgeを使って到達できる\n        int k = 0;\n        cmp.assign(N, -1);\n        for (int i = N - 1; i >= 0; i--) {\n            if (cmp[vs[i]] == -1) rdfs(vs[i], k++);\n        }\n        return k;\n    }\n    // 有向グラフの閉路検出、O(E + V)\n    bool has_loop() { return scc() < N; }\n};\n",
        "description": "StronglyConnectedComponent"
    },
    "AllDirectionTreeDP.cpp": {
        "prefix": "AllDirectionTreeDP",
        "body": "// 全方位木DP\n// ds[v]: vを根としたときのそれぞれの葉までの距離\nsigned main() {\n    struct Edge {\n        int to, c;\n    };\n    int n;\n    cin >> n;\n    vector<vector<Edge>> G(n);\n    REP(i, n - 1) {\n        int s, t, w;\n        cin >> s >> t >> w;\n        G[s].push_back({t, w});\n        G[t].push_back({s, w});\n    }\n    VVII ds(n);\n    function<int(int, int)> dfs1 = [&](int v, int p) {\n        int ma = 0;\n        for (Edge e : G[v])\n            if (e.to != p) {\n                int tmp = dfs1(e.to, v) + e.c;\n                ds[v].push_back({tmp, e.to});\n                ma = max(ma, tmp);\n            }\n        return ma;\n    };\n    dfs1(0, -1);\n\n    sort(RALL(ds[0]));\n    function<void(int, int)> dfs2 = [&](int v, int p) {\n        for (Edge e : G[v])\n            if (e.to != p) {\n                int tmp = (ds[v][0].se != e.to ? ds[v][0].fi : (ds[v].size() == 1 ? 0 : ds[v][1].fi)) + e.c;\n                ds[e.to].push_back({tmp, v});\n                sort(RALL(ds[e.to]));\n                dfs2(e.to, v);\n            }\n    };\n    dfs2(0, -1);\n\n    int ans = 0;\n    REP(i, n) {\n        if (ds[i].size() == 0) continue;\n        ans = max(ans, ds[i][0].fi);\n    }\n    cout << ans << endl;\n}\n",
        "description": "AllDirectionTreeDP"
    },
    "ErdosGallai.cpp": {
        "prefix": "ErdosGallai",
        "body": "// Erdos-Gallai theorem: (O(n))\n// https://en.wikipedia.org/wiki/Erdős–Gallai_theorem\nbool is_graphic(const VI& d) {\n    int n = d.size();\n    if (accumulate(ALL(d), 0LL) % 2) return false;\n    VI acc(n + 1);\n    REP(i, n) { acc[i + 1] = acc[i] + d[i]; }\n    int l = n - 1;  // d[l] >= i + 1を満たす最大のl\n    REP(i, n) {\n        int lhs = acc[i + 1];\n        while (l >= i + 1 && d[l] < i + 1) l--;\n        // [i + 1, l]: i + 1, [l + 1, n - 1]: acc\n        int rhs = i * (i + 1) + (i + 1) * (l - i) + (acc[n] - acc[l + 1]);\n        if (lhs > rhs) return false;\n    }\n    return true;\n}\n\nsigned main() {\n    // verify: https://atcoder.jp/contests/yahoo-procon2018-qual/submissions/3925879\n    int n;\n    cin >> n;\n    VI d(n);\n    REP(i, n) cin >> d[i];\n\n    sort(RALL(d));\n    if (is_graphic(d)) {\n        cout << \"YES\" << endl;\n    } else {\n        d.back() += 1;\n        sort(RALL(d));\n        if (is_graphic(d)) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"ABSOLUTELY NO\" << endl;\n        }\n    }\n}\n",
        "description": "ErdosGallai"
    },
    "FFT.cpp": {
        "prefix": "FFT",
        "body": "struct FFT {\n    using comp = complex<double>;\n    static void fft(vector<comp>& a, bool inv = false) {\n        int N = a.size();\n        if (N == 1) {\n            return;\n        }\n        vector<comp> even(N / 2), odd(N / 2);\n        for (int i = 0; i < N / 2; i++) {\n            even[i] = a[2 * i];\n            odd[i] = a[2 * i + 1];\n        }\n        fft(even, inv);\n        fft(odd, inv);\n        comp omega = polar(1.0, (-2 * inv + 1) * 2 * M_PI / N);\n        comp acc_omega = comp(1);\n        for (int i = 0; i < N / 2; i++) {\n            a[i] = even[i] + acc_omega * odd[i];\n            a[i + N / 2] = even[i] - acc_omega * odd[i];\n            acc_omega *= omega;\n        }\n    }\n    static void conv(vector<int>& a, vector<int>& b) {\n        int N = 1;\n        while (N < 2 * (max(a.size(), b.size() + 1))) {\n            N *= 2;\n        }\n        vector<comp> ac(N, comp(0)), bc(N, comp(0));\n        for (int i = 0; i < a.size(); i++) ac[i] = comp(a[i]);\n        for (int i = 0; i < b.size(); i++) bc[i] = comp(b[i]);\n        multiply(ac, bc);\n        a.resize(N);\n        for (int i = 0; i < N; i++) {\n            a[i] = (int)(ac[i].real() + 0.5);\n        }\n    }\n\nprivate:\n    static void multiply(vector<comp>& a, vector<comp>& b) {\n        int n = a.size();\n        fft(a);\n        fft(b);\n        for (int i = 0; i < n; i++) {\n            a[i] *= b[i] / comp(n);\n        }\n        fft(a, true);\n    }\n};\n",
        "description": "FFT"
    },
    "ArithmeticParser.cpp": {
        "prefix": "ArithmeticParser",
        "body": "// 四則演算のParser\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n// exp1 = exp2 [ ('+'|'-') exp2 ]*\n// exp2 = exp3 [ ('*'|'/') exp3 ]*\n// exp3 = '(' exp1 ')' | number\n\nint exp1(const string& s, int& i);\nint exp2(const string& s, int& i);\nint exp3(const string& s, int& i);\nint number(const string& s, int& i);\nint exp1(const string& s, int& i) {\n    int acc = exp2(s, i);\n    while (1) {\n        if (s[i] == '+')\n            acc += exp2(s, ++i);\n        else if (s[i] == '-')\n            acc -= exp2(s, ++i);\n        else\n            return acc;\n    }\n}\nint exp2(const string& s, int& i) {\n    int acc = exp3(s, i);\n    while (1) {\n        if (s[i] == '*')\n            acc *= exp3(s, ++i);\n        else if (s[i] == '/')\n            acc /= exp3(s, ++i);\n        else\n            return acc;\n    }\n}\nint exp3(const string& s, int& i) {\n    if (s[i] == '(') {\n        int ret = exp1(s, ++i);\n        assert(s[i] == ')');\n        i++;\n        return ret;\n    }\n    return number(s, i);\n}\nint number(const string& s, int& i) {\n    int acc = 0;\n    while (isdigit(s[i])) {\n        acc = acc * 10 + (s[i++] - '0');\n    }\n    return acc;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int i = 0;\n    cout << exp1(s, i) << endl;\n    assert(s[i] == '=');\n}\nsigned main() {\n    int T;\n    cin >> T;\n    while (T--) solve();\n}\n",
        "description": "ArithmeticParser"
    },
    "BinarySearch.cpp": {
        "prefix": "BinarySearch",
        "body": "auto check = [&](int mid) -> bool {};\nInt ok = 0, ng = 1e18;\nwhile (abs(ok - ng) > 1) {\n    Int mid = (ok + ng) / 2;\n    (check(mid) ? ok : ng) = mid;\n}\n",
        "description": "BinarySearch"
    },
    "ChineseRemainderTheorem.cpp": {
        "prefix": "ChineseRemainderTheorem",
        "body": "// ax + by = gcd(a, b) を満たす(x, y)\npair<int, int> ext_gcd(int a, int b) {\n    if (b == 0) return {1, 0};\n    pair<int, int> xy = ext_gcd(b, a % b);  // b(qx + y) + rx = ...\n    swap(xy.fi, xy.se);\n    xy.se -= (a / b) * xy.fi;\n    return xy;\n}\nconst pair<int, int> DUM = {0, -1};\n// r = b[i] (mod m[i])\n// r: 剰余, M: mod\npair<int, int> chinese_rem(const VI& b, const VI& m) {\n    int r = 0, M = 1;\n    for (int i = 0; i < b.size(); i++) {\n        pair<int, int> xy = ext_gcd(M, m[i]);\n        int d = __gcd(M, m[i]);\n        if ((b[i] - r) % d != 0) return DUM;\n        int tmp = ((b[i] - r) / d) * xy.fi % (m[i] / d);\n        r += M * tmp;\n        M *= m[i] / d;\n    }\n    ((r %= M) += M) %= M;\n    return {r, M};\n}\n\nsigned main() {}\n",
        "description": "ChineseRemainderTheorem"
    },
    "Divisor.cpp": {
        "prefix": "Divisor",
        "body": "// ret[x]: xの約数のvector\n// 構築: O(nlogn)\nvector<vector<signed>> divisor(signed n) {\n    vector<vector<signed>> ret(n + 1);\n    for (signed i = 1; i < n + 1; i++) {\n        ret[i].reserve(log(n) + 1);\n    }\n    for (signed i = 1; i < n + 1; i++) {\n        for (signed j = i; j < n + 1; j += i) {\n            ret[j].push_back(i);\n        }\n    }\n    return ret;\n}\n",
        "description": "Divisor"
    },
    "BitOperation.cpp": {
        "prefix": "BitOperation",
        "body": "\n// Sの部分集合の列挙\nfor (int T = S;; T = (T - 1) & S) {\n    // 操作\n    if (T == 0) break;\n}\n",
        "description": "BitOperation"
    },
    "MillerRabin.cpp": {
        "prefix": "MillerRabin",
        "body": "random_device rnd;\nmt19937 mt(rnd());\nmt19937_64 mt64(rnd());\nint mod_pow(int x, int n, int mod) {\n    if (n <= 0) return 1;\n    int tmp = mod_pow(x, n / 2, mod);\n    return tmp * tmp % mod * (n % 2 ? x : 1) % mod;\n}\nint mod_inv(int x, int mod) { return mod_pow(x, mod - 2, mod); }\n// Miller-Rabin\nbool is_prime(int n, int times = 50) {\n    if (n == 2) return true;\n    if (n % 2 == 0 || n < 2) return false;\n    int d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    while (times--) {\n        int a = rnd() % (n - 2) + 1;\n        int t = d;\n        int y = mod_pow(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t *= 2;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint gen_prime() {\n    int cnt = 0;\n    while (1) {\n        int n = mt();\n        n != 1;\n        if (is_prime(n)) return n;\n    }\n}\n",
        "description": "MillerRabin"
    },
    "GaussJordan.cpp": {
        "prefix": "GaussJordan",
        "body": "// A[n-1]にはAx = bのbの値\ntemplate <class T>\nvoid gauss_jordan(vector<vector<T>>& A) {\n    int n = A.size(), m = A[0].size();\n    vector<bool> used(n);\n    for (int col = 0; col < m - 1; col++) {\n        int pivot = -1;\n        for (int row = 0; row < n; row++) {\n            if (!used[row] && A[row][col] != 0) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        used[pivot] = true;\n        for (int row = 0; row < n; row++) {\n            if (row == pivot) continue;\n            T d = A[row][col] / A[pivot][col];  // 倍率\n            for (int col2 = 0; col2 < m; col2++) {\n                A[row][col2] -= A[pivot][col2] * d;\n            }\n        }\n    }\n}\n",
        "description": "GaussJordan"
    },
    "Matrix.cpp": {
        "prefix": "Matrix",
        "body": "template <class T>\nstruct Matrix {\n    vector<vector<T>> A;\n    Matrix() {}\n    Matrix(int n) : A(n, vector<T>(n, 0)) {}\n    Matrix(const vector<vector<T>> &A) : A(A) {}\n    static Matrix I(int n) {\n        Matrix mat(n);\n        for (int i = 0; i < n; i++) mat[i][i] = 1;\n        return (mat);\n    }\n    int height() const { return (A.size()); }\n    int width() const { return (A[0].size()); }\n    vector<T> &operator[](int k) { return A[k]; }\n    const vector<T> &operator[](int k) const { return (A[k]); }\n    Matrix &operator+=(const Matrix &B) {\n        assert(A.size() == B.A.size() && A[0].size() == B.A[0].size());\n        for (int i = 0; i < A.size(); i++)\n            for (int j = 0; j < A[0].size(); j++) (*this)[i][j] += B[i][j];\n        return (*this);\n    }\n    Matrix &operator-=(const Matrix &B) {\n        assert(A.size() == B.A.size() && A[0].size() == B.A[0].size());\n        for (int i = 0; i < A.size(); i++)\n            for (int j = 0; j < A[0].size(); j++) (*this)[i][j] -= B[i][j];\n        return (*this);\n    }\n    Matrix &operator*=(const Matrix &B) {\n        int n = height(), m = B.width(), p = width();\n        assert(p == B.height());\n        vector<vector<T>> C(n, vector<T>(m, 0));\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                for (int k = 0; k < p; k++) C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);\n        A.swap(C);\n        return (*this);\n    }\n    Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }\n    Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }\n    Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }\n    vector<T> operator*(const vector<T> &x) const {\n        int n = height(), m = width();\n        assert(m == x.size());\n        vector<T> ret(n);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) ret[i] += (*this)[i][j] * x[j];\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os, Matrix &p) {\n        int n = p.height(), m = p.width();\n        for (int i = 0; i < n; i++) {\n            os << \"[\";\n            for (int j = 0; j < m; j++) {\n                os << p[i][j] << (j + 1 == m ? \"]\\n\" : \",\");\n            }\n        }\n        return (os);\n    }\n    T determinant() {\n        Matrix B(*this);\n        assert(width() == height());\n        T ret = 1;\n        for (int i = 0; i < width(); i++) {\n            int idx = -1;\n            for (int j = i; j < width(); j++) {\n                if (B[j][i] != 0) idx = j;\n            }\n            if (idx == -1) return (0);\n            if (i != idx) {\n                ret *= -1;\n                swap(B[i], B[idx]);\n            }\n            ret *= B[i][i];\n            T vv = B[i][i];\n            for (int j = 0; j < width(); j++) {\n                B[i][j] /= vv;\n            }\n            for (int j = i + 1; j < width(); j++) {\n                T a = B[j][i];\n                for (int k = 0; k < width(); k++) {\n                    B[j][k] -= B[i][k] * a;\n                }\n            }\n        }\n        return (ret);\n    }\n};\n",
        "description": "Matrix"
    },
    "DynamicModInt.cpp": {
        "prefix": "DynamicModInt",
        "body": "template <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n// ModInt::set_mod(m)してから使う\nstruct ModInt {\n    static int MD;\n    static map<pair<int, int>, int> tbl_pow;\n    static void set_mod(int mod) {\n        MD = mod;\n        tbl_pow.clear();\n    }\n    int x;\n    ModInt() : x(0) {}\n    ModInt(int x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return pow(*this, MD - 2); }\n    friend ostream& operator<<(ostream& s, ModInt a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt& a) {\n        s >> a.x;\n        return s;\n    }\n\n    // 計算結果をmapに保存するべき乗\n    ModInt save_pow(int n) const {\n        if (tbl_pow.count({x, n})) return tbl_pow[{x, n}];\n        if (n == 0) return 1;\n        if (n % 2) return tbl_pow[{x, n}] = (*this * save_pow(n - 1)).x;\n        return tbl_pow[{x, n}] = (save_pow(n / 2) * save_pow(n / 2)).x;\n    }\n    // 1 + r + r^2 + ... + r^(n-1)\n    static ModInt geometric_progression(ModInt r, int n) {\n        if (n == 0) return 0;\n        if (n % 2) return geometric_progression(r, n - 1) + r.save_pow(n - 1);\n        return geometric_progression(r, n / 2) * (r.save_pow(n / 2) + 1);\n    }\n    // a + r * (a - d) + r^2 * (a - 2d) + ... + r^(n-1) * (a - (n - 1)d)\n    static ModInt linear_sum(ModInt r, ModInt a, ModInt d, int n) {\n        if (n == 0) return 0;\n        if (n % 2) return linear_sum(r, a, d, n - 1) + r.save_pow(n - 1) * (a - d * (n - 1));\n        return linear_sum(r, a, d, n / 2) * (r.save_pow(n / 2) + 1) -\n               d * (n / 2) * r.save_pow(n / 2) * geometric_progression(r, n / 2);\n    }\n};\nint ModInt::MD = 1000000007;\nusing mint = ModInt;\nmap<pair<int, int>, int> mint::tbl_pow;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n",
        "description": "DynamicModInt"
    },
    "ModInt.cpp": {
        "prefix": "ModInt",
        "body": "template <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n    int x;\n    static unordered_map<int, int> to_inv;\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n    friend ostream& operator<<(ostream& s, ModInt<MD> a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt<MD>& a) {\n        s >> a.x;\n        return s;\n    }\n};\ntemplate <int MD>\nunordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n",
        "description": "ModInt"
    },
    "EulerTotient.cpp": {
        "prefix": "EulerTotient",
        "body": "int euler_totient(int n) {\n    vector<int> ps;\n    {\n        int tmp = n;\n        for (int x = 2; x * x <= tmp; x++) {\n            if (tmp % x) continue;\n            ps.push_back(x);\n            while (tmp % x == 0) tmp /= x;\n        }\n        if (tmp != 1) ps.push_back(tmp);\n    }\n    int m = ps.size();\n    int ans = 0;\n    for (int bit = 0; bit < 1LL << m; bit++) {\n        int d = 1;\n        for (int i = 0; i < m; i++) {\n            if (bit >> i & 1) d *= ps[i];\n        }\n        int sign = __builtin_popcount(bit) % 2 ? -1 : 1;\n        ans += sign * (n / d);\n    }\n    return ans;\n}\n",
        "description": "EulerTotient"
    },
    "Eratosthenes.cpp": {
        "prefix": "Eratosthenes",
        "body": "struct Eratosthenes {\n    vector<bool> is_prime;\n    vector<int> primes;\n    Eratosthenes(int n) {\n        is_prime = vector<bool>(n, true);\n        is_prime[1] = false;\n        for (int i = 2; i < n; i++) {\n            if (!is_prime[i]) continue;\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n        for (int i = 2; i < n; i++) {\n            if (is_prime[i]) primes.push_back(i);\n        }\n    }\n};\n",
        "description": "Eratosthenes"
    },
    "LazySegmentTree.cpp": {
        "prefix": "LazySegmentTree",
        "body": "// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass BaseSegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // 定数倍高速化\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    virtual T0 f0(T0, T0) = 0;\n    const T0 u0;\n    // T1上の演算、単位元\n    virtual T1 f1(T1, T1) = 0;\n    const T1 u1;\n    // T0に対するT1の作用\n    virtual T0 g(T0, T1) = 0;\n    // 多数のt1(T1)に対するf1の合成\n    virtual T1 p(T1, int) = 0;\n\n    BaseSegmentTree(T0 u0, T1 u1) : u0(u0), u1(u1) {}\n    void set_by_vector(const vector<T0>& a) {\n        sz = a.size();\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n        for (int i = 0; i < sz; i++) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    void set_by_unit(int n) {\n        sz = n;\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n};\n\ntemplate <class T0, class T1>\nstruct MinUpdateQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr T0 _u0 = numeric_limits<T0>::max();\n    static constexpr T1 _u1 = numeric_limits<T1>::min();\n    MinUpdateQuery() : MinUpdateQuery(_u0, _u1) {}\n    T0 f0(T0 x, T0 y) override { return min(x, y); }\n    T1 f1(T1 x, T1 y) override { return y == _u1 ? x : y; }\n    T0 g(T0 x, T1 y) override { return y == _u1 ? x : y; }\n    T1 p(T1 x, int len) override { return x; }\n};\n\ntemplate <class T0, class T1>\nstruct SumAddQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    SumAddQuery() : SumAddQuery(0, 0) {}\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return x + y; }\n    T0 g(T0 x, T1 y) override { return x + y; }\n    T1 p(T1 x, int len) override { return x * len; }\n};\n\ntemplate <class T0, class T1>\nstruct MinAddQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr int _u0 = numeric_limits<T0>::max();\n    MinAddQuery() : MinAddQuery(_u0, 0) {}\n    T0 f0(T0 x, T0 y) override { return min(x, y); }\n    T1 f1(T1 x, T1 y) override { return x + y; }\n    T0 g(T0 x, T1 y) override { return x + y; }\n    T1 p(T1 x, int len) override { return x; }\n};\n\ntemplate <class T0, class T1>\nstruct SumUpdateQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr int _u1 = numeric_limits<T1>::min();\n    SumUpdateQuery() : SumUpdateQuery(0, _u1) {}\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return y == _u1 ? x : y; }\n    T0 g(T0 x, T1 y) override { return y == _u1 ? x : y; }\n    T1 p(T1 x, int len) override { return x == _u1 ? _u1 : x * len; }\n};\n\ntemplate <class T0>\nstruct SumAffineQuery : public BaseSegmentTree<T0, pair<T0, T0>> {\n    using T1 = pair<T0, T0>;  // first * x + second\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr T1 _u1 = {1, 0};\n    SumAffineQuery() : SumAffineQuery(0, {1, 0}) {}  // TODO: _u1を使うとコンパイル通らない原因不明\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }\n    T0 g(T0 x, T1 y) override { return y.first * x + y.second; }\n    T1 p(T1 x, int len) override { return {x.first, x.second * len}; }\n    // update(i, j, {a, b}); // [i, j)にax + bを作用\n    // update(i, j, {0, a}); // update\n    // update(i, j, {1, a}); // 加算\n    // update(i, j, {a, 0}); // 倍\n};\n\ntemplate <class T>\nstruct MinmaxAffineQuery : public BaseSegmentTree<pair<T, T>, pair<T, T>> {\n    using T0 = pair<T, T>;  // {min, max}\n    using T1 = pair<T, T>;  // first * x + second\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr T0 get_u0() { return {numeric_limits<T>::max(), -numeric_limits<T>::max()}; }\n    static constexpr T1 _u1 = {1, 0};\n    MinmaxAffineQuery() : MinmaxAffineQuery(get_u0(), {1, 0}) {}  // TODO: _u1を使うとコンパイル通らない原因不明\n    T0 f0(T0 x, T0 y) override { return {min(x.first, y.first), max(x.second, y.second)}; }\n    T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }\n    T0 g(T0 x, T1 y) override {\n        T0 ret = {x.first * y.first + y.second, x.second * y.first + y.second};\n        if (y.first < 0) swap(ret.first, ret.second);\n        return ret;\n    }\n    T1 p(T1 x, int len) override { return x; }\n    // update(i, j, {a, b}); // [i, j)にax + bを作用\n    // update(i, j, {0, a}); // update\n    // update(i, j, {1, a}); // 加算\n    // update(i, j, {a, 0}); // 倍\n};\n",
        "description": "LazySegmentTree"
    },
    "SegmentTree.cpp": {
        "prefix": "SegmentTree",
        "body": "template <class T, class F>\nstruct SegmentTree {\n    const F op;\n    const T e;\n    SegmentTree(F op_, T e_) : op(op_), e(e_) {}\n    int n;\n    vector<T> t;\n    void set_by_unit(int n_) {\n        t.clear();\n        n = n_;\n        t.resize(2 * n, e);\n    }\n    void set_by_vector(const vector<T>& a) {\n        t.clear();\n        n = a.size();\n        t.resize(2 * n, e);\n        for (int i = 0; i < n; i++) t[i + n] = a[i];\n        build();\n    }\n    void build() {\n        for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n    T& operator[](int i) { return t[i + n]; }\n    // [l, r)\n    T query(int l, int r) const {\n        assert(0 <= l && l <= r && r <= n);\n        T resl = e, resr = e;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) resl = op(resl, t[l++]);\n            if (r & 1) resr = op(t[--r], resr);\n        }\n        return op(resl, resr);\n    }\n    // iをaに変更\n    void update(int i, const T& a) {\n        assert(0 <= i && i < n);\n        t[i += n] = a;\n        while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n};\ntemplate <class T, class F>\nauto make_segment_tree(F op, T e) {\n    return SegmentTree<T, F>(op, e);\n}\n// example\n//     auto seg_mi = make_segment_tree<Int>([](Int a, Int b) { return min(a, b); }, 1e18);\n//     auto seg_ma = make_segment_tree<Int>([](Int a, Int b) { return max(a, b); }, -1e18);\n",
        "description": "SegmentTree"
    },
    "UnionFindWithWeight.cpp": {
        "prefix": "UnionFindWithWeight",
        "body": "struct UnionFind {\n    vector<int> par, rank, diff_weight;\n    UnionFind(int n) {\n        par = vector<int>(n);\n        iota(par.begin(), par.end(), 0);\n        rank = vector<int>(n, 0);\n        diff_weight = vector<int>(n, 0);\n    }\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            int r = root(par[x]);\n            diff_weight[x] += diff_weight[par[x]];\n            return par[x] = root(par[x]);\n        }\n    }\n    bool unite(int x, int y, int w) {\n        w += weight(x);\n        w -= weight(y);\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return false;\n        }\n        if (rank[x] < rank[y]) {\n            diff_weight[x] -= w;\n            par[x] = y;\n        } else {\n            diff_weight[y] += w;\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int weight(int x) {\n        root(x);\n        return diff_weight[x];\n    }\n    int diff(int x, int y) {\n        assert(same(x, y));\n        return weight(y) - weight(x);\n    }\n};\n",
        "description": "UnionFindWithWeight"
    },
    "BinaryIndexedTree.cpp": {
        "prefix": "BinaryIndexedTree",
        "body": "// 0-indexed\nclass BinaryIndexedTree {\n    int max_pow;  // N以下の最大の2べき\npublic:\n    vector<int> bit;\n    int N;\n    BinaryIndexedTree(int n, int x = 0) : N(n), bit(n, x) {\n        for (max_pow = 1; max_pow <= N / 2; max_pow *= 2)\n            ;\n    }\n    BinaryIndexedTree(const vector<int>& a) : N(a.size()), bit(a) {\n        for (max_pow = 1; max_pow <= N / 2; max_pow *= 2)\n            ;\n        REP(i, N - 1) if ((i | (i + 1)) < N) { bit[i | (i + 1)] += bit[i]; }\n    }\n    // k番目にxを加算\n    void add(int k, int x) {\n        for (int i = k; i < N; i |= i + 1) {\n            bit[i] += x;\n        }\n    }\n\n    // [0, k)、k == 0のときは0を返す\n    int sum(int k) {\n        int ret = 0;\n        for (int i = k - 1; i >= 0; i = (i & (i + 1)) - 1) {\n            ret += bit[i];\n        }\n        return ret;\n    }\n    int sum() { return sum(N); }\n\n    // [a, b)\n    int query(int a, int b) {\n        assert(a <= b);\n        return sum(b) - sum(a);\n    }\n    int operator[](int k) { return query(k, k + 1); }\n\n    // k番目をxに\n    void update(int k, int x) { add(k, x - operator[](k)); }\n\n    // 注: 中身が全て正のときしか動かない\n    // sum(i + 1) >= xとなるような最小のi\n    int lower_bound(int x) {\n        int i = -1;\n        for (int w = max_pow; w > 0; w /= 2) {\n            if (i + w < N && bit[i + w] < x) {\n                x -= bit[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) >= xとなるような最小のi\n    int lower_bound(int begin, int x) {\n        int lb = lower_bound(x + sum(begin));\n        return max(begin, lb);\n    }\n    // sum(i + 1) > xとなるような最小のi\n    int upper_bound(int x) {\n        int i = -1;\n        for (int w = max_pow; w > 0; w /= 2) {\n            if (i + w < N && bit[i + w] <= x) {\n                x -= bit[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) > xとなるような最小のi\n    int upper_bound(int begin, int x) {\n        int ub = upper_bound(x + sum(begin));\n        return max(begin, ub);\n    }\n};\n",
        "description": "BinaryIndexedTree"
    },
    "DynamicUnionFind.cpp": {
        "prefix": "DynamicUnionFind",
        "body": "struct DynamicUnionFind {\n    unordered_map<int, int> number;\n    // 頂点xが入っていなかったら追加\n    struct Data {\n        Data() {}\n        void merge(Data& s) {\n            // 自分で定義\n        }\n    };\n    unordered_map<int, Data> data;\n\n    int root(int x) {\n        if (!number.count(x)) number[x] = -1;\n        return number[x] < 0 ? x : number[x] = root(number[x]);\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        // dataのマージ方法に合わせて変える\n        data[x].merge(data[y]);\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n    Data& ref(int x) { return data[root(x)]; }\n};\n",
        "description": "DynamicUnionFind"
    },
    "ConvexHullTrick.cpp": {
        "prefix": "ConvexHullTrick",
        "body": "template <typename T, const T id = (int)-1e18>\nclass convex_hull_trick {\n    struct line {\n        T a, b;\n        line(T a_ = 0, T b_ = 0) : a(a_), b(b_) {}\n        T get(T x) { return a * x + b; }\n    };\n    struct node {\n        line l;\n        node *lch, *rch;\n        node(line l_) : l(l_), lch(nullptr), rch(nullptr) {}\n        ~node() {\n            if (lch) delete lch;\n            if (rch) delete rch;\n        }\n    };\n\nprivate:\n    const int n;\n    const vector<T> pos;\n    node *root;\n\npublic:\n    convex_hull_trick(const vector<T> &pos_) : n(pos_.size()), pos(pos_), root(nullptr) {}\n    ~convex_hull_trick() {\n        if (root) delete root;\n    }\n    // maxを求めるとき\n    void insert(T a, T b) {\n        line l(a, b);\n        root = modify(root, 0, n - 1, l);\n    }\n    T get(T x) const {\n        int t = lower_bound(pos.begin(), pos.end(), x) - pos.begin();\n        assert(t < n && pos[t] == x);\n        return sub(root, 0, n - 1, t);\n    }\n    // minを求めるとき\n    void rev_insert(T a, T b) { insert(-a, -b); }\n    T rev_get(T x) const { return -get(x); }\n\nprivate:\n    node *modify(node *p, int lb, int ub, line &l) {\n        if (!p) return new node(l);\n        if (p->l.get(pos[lb]) >= l.get(pos[lb]) && p->l.get(pos[ub]) >= l.get(pos[ub])) return p;\n        if (p->l.get(pos[lb]) <= l.get(pos[lb]) && p->l.get(pos[ub]) <= l.get(pos[ub])) {\n            p->l = l;\n            return p;\n        }\n        int c = (lb + ub) / 2;\n        if (p->l.get(pos[c]) < l.get(pos[c])) swap(p->l, l);\n        if (p->l.get(pos[lb]) <= l.get(pos[lb]))\n            p->lch = modify(p->lch, lb, c, l);\n        else\n            p->rch = modify(p->rch, c + 1, ub, l);\n        return p;\n    }\n    T sub(node *p, int lb, int ub, int t) const {\n        if (!p) return id;\n        if (ub - lb == 0) return p->l.get(pos[t]);\n        int c = (lb + ub) / 2;\n        if (t <= c) return max(p->l.get(pos[t]), sub(p->lch, lb, c, t));\n        return max(p->l.get(pos[t]), sub(p->rch, c + 1, ub, t));\n    }\n};\n",
        "description": "ConvexHullTrick"
    },
    "UnionFindWithData.cpp": {
        "prefix": "UnionFindWithData",
        "body": "struct UnionFind {\n    int cnt;             // 集合の数\n    vector<int> number;  // 0以上のとき親のindex, 負のときは集合サイズ\n    struct Data {\n        Data() {}\n        void merge(Data& s) {\n            // 自分で定義\n        }\n    };\n    vector<Data> data;\n\n    UnionFind(int n) : cnt(n), number(n, -1), data(n) {}\n    int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        // dataのマージ方法に合わせて変える\n        data[x].merge(data[y]);\n\n        cnt--;\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n    Data& ref(int x) { return data[root(x)]; }\n};\n",
        "description": "UnionFindWithData"
    },
    "UnionFindRange.cpp": {
        "prefix": "UnionFindRange",
        "body": "// 1次元上の要素のマージをしていくときに、各連結成分の[left, right)を更新\nstruct UnionFind {\n    int cnt;                      // 集合の数\n    vector<int> number;           // 0以上のとき親のindex, 負のときは集合サイズ\n    vector<pair<int, int>> data;  // [left, right)\n    UnionFind(int n) : cnt(n), number(n, -1), data(n) {\n        for (int i = 0; i < n; i++) data[i] = {i, i + 1};\n    }\n    int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        // dataのマージ方法に合わせて変える\n        data[x] = {min(data[x].first, data[y].first), max(data[x].second, data[y].second)};\n        cnt--;\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n    int& left(int x) { return data[root(x)].first; }\n    int& right(int x) { return data[root(x)].second; }\n    pair<int, int>& ref(int x) { return data[root(x)]; }\n};\n",
        "description": "UnionFindRange"
    },
    "Doubling.cpp": {
        "prefix": "Doubling",
        "body": "struct Doubling {\n    int n;\n    int size;                  // MSB + 1\n    vector<vector<int>> next;  // next[k][i]: iから(1<<k)回でどこまで進めるか\n\n    // edge[i]: 1回でiからどこまで進めるか\n    Doubling(vector<int>& edge) : n(edge.size()), size(64 - __builtin_clzll(edge.size())) {\n        next.resize(size, vector<int>(n + 1, n));\n        for (int i = 0; i < n; i++) next[0][i] = edge[i];\n        for (int k = 0; k < size - 1; k++) {\n            for (int i = 0; i < n; i++) {\n                next[k + 1][i] = next[k][next[k][i]];\n            }\n        }\n    }\n    // i番目のx個先\n    int get(int i, int x) {\n        int ret = i;\n        for (int bit = 0; bit < size; bit++) {\n            if (!(x >> bit & 1)) continue;\n            ret = next[bit][ret];\n        }\n        return ret;\n    }\n    // iからはじめて何回進めば初めてj以上になるか\n    // j以上になりえないときはnを返す\n    int lower_bound(int i, int j) {\n        int cur = i, acc = 0;\n        for (int wid = size - 1; wid >= 0; wid--) {\n            if (next[wid][cur] < j) {\n                acc += 1LL << wid;\n                cur = next[wid][cur];\n            }\n        }\n        return min(n, acc + 1);\n    }\n};\n",
        "description": "Doubling"
    },
    "SlideMin.cpp": {
        "prefix": "SlideMin",
        "body": "// 自分を含んだK個前までの中での最小値のindexの配列を返す\n// 最小(最大)値のindexを返すことに注意!\ntemplate <class T = int>\nvector<int> slide_min(const vector<T>& a, int w, function<bool(T, T)> cmp = less<T>()) {\n    int n = a.size();\n    vector<int> ret(n);\n    deque<int> dq;\n    for (int i = 0; i < n; i++) {\n        while (!dq.empty() && !cmp(a[dq.back()], a[i])) {\n            dq.pop_back();\n        }\n        dq.push_back(i);\n        while (dq.front() <= i - w) {\n            dq.pop_front();\n        }\n        ret[i] = dq.front();\n    }\n    return ret;\n}\n",
        "description": "SlideMin"
    },
    "ReversedBinaryIndexedTree.cpp": {
        "prefix": "ReversedBinaryIndexedTree",
        "body": "// 0-indexed\nclass BinaryIndexedTree {\n    int max_pow;  // N以下の最大の2べき\npublic:\n    vector<int> bit;\n    int N;\n    BinaryIndexedTree(int n, int x = 0) : N(n), bit(n, x) {\n        for (max_pow = 1; max_pow <= N / 2; max_pow *= 2)\n            ;\n    }\n    BinaryIndexedTree(const vector<int>& a) : N(a.size()), bit(a) {\n        for (max_pow = 1; max_pow <= N / 2; max_pow *= 2)\n            ;\n        REP(i, N - 1) if ((i | (i + 1)) < N) { bit[i | (i + 1)] += bit[i]; }\n    }\n    // k番目にxを加算\n    void add(int k, int x) {\n        for (int i = k; i < N; i |= i + 1) {\n            bit[i] += x;\n        }\n    }\n\n    // [0, k)、k == 0のときは0を返す\n    int sum(int k) {\n        int ret = 0;\n        for (int i = k - 1; i >= 0; i = (i & (i + 1)) - 1) {\n            ret += bit[i];\n        }\n        return ret;\n    }\n    int sum() { return sum(N); }\n\n    // [a, b)\n    int query(int a, int b) {\n        assert(a <= b);\n        return sum(b) - sum(a);\n    }\n    int operator[](int k) { return query(k, k + 1); }\n\n    // k番目をxに\n    void update(int k, int x) { add(k, x - operator[](k)); }\n\n    // 注: 中身が全て正のときしか動かない\n    // sum(i + 1) >= xとなるような最小のi\n    int lower_bound(int x) {\n        int i = -1;\n        for (int w = max_pow; w > 0; w /= 2) {\n            if (i + w < N && bit[i + w] < x) {\n                x -= bit[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) >= xとなるような最小のi\n    int lower_bound(int begin, int x) {\n        int lb = lower_bound(x + sum(begin));\n        return max(begin, lb);\n    }\n    // sum(i + 1) > xとなるような最小のi\n    int upper_bound(int x) {\n        int i = -1;\n        for (int w = max_pow; w > 0; w /= 2) {\n            if (i + w < N && bit[i + w] <= x) {\n                x -= bit[i + w];\n                i += w;\n            }\n        }\n        return i + 1;\n    }\n    // query[begin, i + 1) > xとなるような最小のi\n    int upper_bound(int begin, int x) {\n        int ub = upper_bound(x + sum(begin));\n        return max(begin, ub);\n    }\n};\n\n// 大きい方からlower_boundなどをしたいときのwrapper\n// 政府逆転させて(-N, 0]にして、平行移動して[0, N)にしている\nclass ReversedBinaryIndexedTree : public BinaryIndexedTree {\npublic:\n    using BinaryIndexedTree::BinaryIndexedTree;\n    int rev(int k) { return N - 1 - k; }\n    void add(int k, int x) { BinaryIndexedTree::add(rev(k), x); }\n    // (k, N-1]\n    int sum(int k) { return BinaryIndexedTree::sum(rev(k)); }\n    // query(i - 1, N-1] >= xとなるような最大nのi\n    int lower_bound(int x) { return rev(BinaryIndexedTree::lower_bound(x)); }\n    // query(i - 1, N-1] > xとなるような最大nのi\n    int upper_bound(int x) { return rev(BinaryIndexedTree::upper_bound(x)); }\n};\n",
        "description": "ReversedBinaryIndexedTree"
    },
    "Accumulate2D.cpp": {
        "prefix": "Accumulate2D",
        "body": "template <class T>\nstruct Accumulate2D {\n    vector<vector<T>> t;  // 0-indexed!!\n    Accumulate2D(int n, int m) : t(n + 1, vector<T>(m + 1)) {}\n    T get(int i, int j) { return (i < 0 || j < 0) ? 0 : t[i][j]; }\n\n    // i0 <= i < i1, j0 < j < j1の範囲に+x\n    // このあとにrunする必要あり！\n    void add(int i0, int j0, int i1, int j1, T x) {\n        t[i0][j0] += x;\n        t[i1][j0] -= x;\n        t[i0][j1] -= x;\n        t[i1][j1] += x;\n    }\n\n    // 累積和を取る\n    void run() {\n        for (int i = 0; i < t.size(); i++) {\n            for (int j = 0; j < t[0].size(); j++) {\n                t[i][j] += get(i, j - 1) + get(i - 1, j) - get(i - 1, j - 1);\n            }\n        }\n    }\n\n    // i0 <= i < i1, j0 < j < j1の範囲のsumを求める\n    // runをしてから使う！\n    T query(int i0, int j0, int i1, int j1) {\n        return get(i1 - 1, j1 - 1) - get(i1 - 1, j0 - 1) - get(i0 - 1, j1 - 1) + get(i0 - 1, j0 - 1);\n    }\n};\n",
        "description": "Accumulate2D"
    },
    "QuickFind.cpp": {
        "prefix": "QuickFind",
        "body": "class QuickFind {\npublic:\n    int N;\n    vector<int> i2g;          // 各頂点のグループ\n    vector<vector<int>> g2i;  // 各グループの頂点集合\n    QuickFind(int n) : N(n) {\n        i2g.resize(N);\n        g2i = vector<vector<int>>(N, vector<int>(1));\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n            g2i[i][0] = i;\n        }\n    }\n    // iを含むグループとjを含むグループをmerge\n    void merge(int i, int j) {\n        int gi = i2g[i], gj = i2g[j];\n        if (gi == gj) return;\n        if (g2i[gi].size() < g2i[j].size()) swap(gi, gj);\n        // jをiにmerge\n        for (int v : g2i[gj]) i2g[v] = gi;\n        g2i[gi].insert(g2i[gi].end(), g2i[gj].begin(), g2i[gj].end());\n        g2i[gj].clear();\n    }\n    bool same(int i, int j) { return i2g[i] == i2g[j]; }\n};\n",
        "description": "QuickFind"
    },
    "UnionFind.cpp": {
        "prefix": "UnionFind",
        "body": "struct UnionFind {\n    int cnt;                   // 集合の数\n    vector<int> number;        // 0以上のとき親のindex, 負のときは集合サイズ\n    vector<int> data1, data2;  // 連結成分ごとのデータ\n    UnionFind(int n) : cnt(n), number(n, -1) {}\n    UnionFind(const vector<int>& data1, const vector<int>& data2)\n        : cnt(data1.size()), number(data1.size(), -1), data1(data1), data2(data2) {}\n    int root(int x) { return number[x] < 0 ? x : number[x] = root(number[x]); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (number[y] < number[x]) swap(x, y);\n        // yをxにマージ\n        number[x] += number[y];\n        number[y] = x;\n        // // dataのマージ方法に合わせて変える\n        // data1[x] += data1[y];\n        // data2[x] += data2[y];\n        cnt--;\n    }\n    bool is_same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -number[root(x)]; }\n    int& ref1(int x) { return data1[root(x)]; }\n    int& ref2(int x) { return data2[root(x)]; }\n};\n",
        "description": "UnionFind"
    },
    "SuffixArray.cpp": {
        "prefix": "SuffixArray",
        "body": "// SA-ISによるSuffix Arrayの実装。構築O(N)\nclass SuffixArray {\n    vector<int> sa_is(const vector<int>& str, const int k) {\n        const int n = str.size();\n        vector<bool> is_S(n);\n        is_S[n - 1] = true;\n        vector<bool> is_LMS(n);\n        vector<int> LMSs;\n        for (int i = n - 2; i >= 0; i--) {\n            is_S[i] = str[i] < str[i + 1] || (str[i] == str[i + 1] && is_S[i + 1]);\n        }\n        REP(i, n) {\n            if (is_S[i] & (i == 0 || !is_S[i - 1])) {\n                is_LMS[i] = true;\n                LMSs.push_back(i);\n            }\n        }\n        vector<int> pseudo_sa = induced_sort(str, LMSs, is_S, k);\n        vector<int> orderedLMSs(LMSs.size());\n        int index = 0;\n        for (int x : pseudo_sa) {\n            if (is_LMS[x]) {\n                orderedLMSs[index++] = x;\n            }\n        }\n        pseudo_sa[orderedLMSs[0]] = 0;\n        int rank = 0;\n        if (orderedLMSs.size() > 1) {\n            pseudo_sa[orderedLMSs[1]] = ++rank;\n        }\n        REPI(i, 1, orderedLMSs.size() - 1) {\n            bool is_diff = false;\n            REP(j, n) {\n                int p = orderedLMSs[i] + j;\n                int q = orderedLMSs[i + 1] + j;\n                if (str[p] != str[q] || is_LMS[p] != is_LMS[q]) {\n                    is_diff = true;\n                    break;\n                }\n                if (j > 0 && is_LMS[p]) {\n                    break;\n                }\n            }\n            pseudo_sa[orderedLMSs[i + 1]] = is_diff ? ++rank : rank;\n        }\n        vector<int> new_str(LMSs.size());\n        index = 0;\n        REP(i, n) {\n            if (is_LMS[i]) {\n                new_str[index++] = pseudo_sa[i];\n            }\n        }\n        vector<int> LMS_sa;\n        if (rank + 1 == LMSs.size()) {\n            LMS_sa = orderedLMSs;\n        } else {\n            LMS_sa = sa_is(new_str, rank + 1);\n            for (int& x : LMS_sa) {\n                x = LMSs[x];\n            }\n        }\n        return induced_sort(str, LMS_sa, is_S, k);\n    }\n\n    vector<int> induced_sort(const vector<int>& str, const vector<int>& LMSs, const vector<bool>& is_S, const int k) {\n        int n = str.size();\n        vector<int> buckets(n);\n        vector<int> chars(k + 1);\n        for (int c : str) {\n            chars[c + 1]++;\n        }\n        REP(i, k) { chars[i + 1] += chars[i]; }\n        vector<int> count(k);\n        for (int i = LMSs.size() - 1; i >= 0; i--) {\n            int c = str[LMSs[i]];\n            buckets[chars[c + 1] - 1 - count[c]++] = LMSs[i];\n        }\n        count = vector<int>(k);\n        REP(i, n) {\n            if (buckets[i] == 0 || is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c] + count[c]++] = buckets[i] - 1;\n        }\n        count = vector<int>(k);\n        for (int i = n - 1; i >= 0; i--) {\n            if (buckets[i] == 0 || !is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c + 1] - 1 - count[c]++] = buckets[i] - 1;\n        }\n        return buckets;\n    }\n\npublic:\n    string S;\n    int N;\n    vector<int> sa;  // sa[i]: suffixが辞書順i番目となる開始位置のindex\n    SuffixArray(string str_in) : S(str_in), N(str_in.size()) {\n        str_in += \"$\";\n        vector<int> str(N + 1);\n        REP(i, N + 1) { str[i] = str_in[i] - '$'; }\n        sa = sa_is(str, 128);\n        sa.erase(sa.begin());\n    }\n    int operator[](int index) { return sa[index]; }\n\n    // sizeがTと等しく初めてT以上になるようなSの部分文字列(sa)\n    vector<int>::iterator lower_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) < 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // sizeがTと等しく初めてTより大きくなるようなSの部分文字列(sa)\n    vector<int>::iterator upper_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) <= 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // S2が部分文字列として何回出現するか\n    int count(string S2) { return upper_bound(S2) - lower_bound(S2); }\n};\n",
        "description": "SuffixArray"
    },
    "Manacher.cpp": {
        "prefix": "Manacher",
        "body": "template <class T>\nvector<int> manacher(const vector<T>& s) {\n    vector<int> R(s.size());\n    int i = 0, j = 0;\n    while (i < s.size()) {\n        while (i - j >= 0 && i + j < s.size() && s[i - j] == s[i + j]) ++j;\n        R[i] = j;\n        int k = 1;\n        while (i - k >= 0 && i + k < s.size() && k + R[i - k] < j) R[i + k] = R[i - k], ++k;\n        i += k;\n        j -= k;\n    }\n    return R;\n}\n\nstruct Manacher {\n    vector<int> a;\n    template <class T>\n    Manacher(const vector<T>& s, T DUMMY = -1) {\n        int m = s.size() * 2 - 1;\n        vector<T> t(m, DUMMY);\n        for (int i = 0; i < s.size(); i++) {\n            t[i * 2] = s[i];\n        }\n        a = manacher(t);\n    }\n    Manacher(const string& s, char DUMMY = '$') {\n        int m = s.size() * 2 - 1;\n        vector<char> t(m, DUMMY);\n        for (int i = 0; i < s.size(); i++) {\n            t[i * 2] = s[i];\n        }\n        a = manacher(t);\n    }\n\n    // [l, r)が回文かどうか\n    bool is_palindrome(int l, int r) { return a[l + r - 1] >= r - l; }\n};\n",
        "description": "Manacher"
    },
    "SuffixArrayDoubling.cpp": {
        "prefix": "SuffixArrayDoubling",
        "body": "template <class T = int>\nclass SegTree {\n    using VT = vector<T>;\n    int orig_n;\n    // k番目のノードの[l, r)について[a, b)を求める\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) {\n            return UNIT;\n        }\n        if (a <= l && r <= b) {\n            return dat[k];\n        }\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\npublic:\n    int N;\n    VT dat;\n    function<T(T, T)> f;\n    int UNIT;\n    SegTree(int n, function<T(T, T)> f_, const T unit) {\n        orig_n = n;\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < n; N *= 2)\n            ;\n        dat = VT(2 * N - 1, UNIT);\n    }\n    SegTree(\n        VT a = {}, function<T(T, T)> f_ = [](int a, int b) { return min(a, b); }, T unit = 1e15) {\n        orig_n = a.size();\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < a.size(); N *= 2)\n            ;\n        dat = VT(2 * N - 1);\n        REP(i, a.size()) { dat[N - 1 + i] = a[i]; }\n        for (int k = N - 2; k >= 0; k--) {\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // k番目をaに\n    void update(int k, int a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // [a, b)でのクエリ\n    T query(int a, int b) {\n        assert(0 <= a && a < b && b <= orig_n);\n        return query(a, b, 0, 0, N);\n    }\n};\n\nclass SuffixArray {\n    SegTree<> rmq;\n    void set_lcp() {\n        // S[i]を順番に見ていきS[i - 1] -　1文字以上が共通することを利用してしゃくとり\n        lcp_next_rank = vector<int>(N);\n        int h = 0;\n        REP(i, N) {\n            if (h > 0) h--;\n            if (rank[i] == N - 1) continue;\n            int j = sorted[rank[i] + 1];  // 比べる対象(辞書順が一つ大きいもの)\n            for (; i + h < N && j + h < N; h++) {\n                if (S[i + h] != S[j + h]) break;\n            }\n            lcp_next_rank[rank[i]] = h;\n        }\n        // S[i..], S[j..]のlcpが求められるようにRMQ上にのせる\n        rmq = SegTree<int>(\n            lcp_next_rank, [](int a, int b) { return min(a, b); }, 1e15);\n    }\n\npublic:\n    int N;\n    string S;\n    vector<int> rank;    // rank[i]: iから始まるsuffixの辞書順での順位\n    vector<int> sorted;  // sorted[i]: suffixが辞書順i番目となる開始位置のindex\n    vector<int> lcp_next_rank;  // lcp[i]: S[sorted[i]..]とS[sorted[i + 1]..]が先頭何文字一致しているか、lcp[N - 1] = 0\n    SuffixArray(string s) {\n        S = s;\n        N = S.size();\n        sorted = vector<int>(N);\n        rank = vector<int>(N);\n        REP(i, N) {\n            sorted[i] = i;\n            rank[i] = S[i];\n        }\n\n        int k;\n        function<bool(int, int)> compare_sa = [this, &k](int i, int j) {\n            if (rank[i] != rank[j]) {\n                return rank[i] < rank[j];\n            }\n            int ri = i + k < N ? rank[i + k] : -1;\n            int rj = j + k < N ? rank[j + k] : -1;\n            return ri < rj;\n        };\n\n        for (k = 1; k < N; k *= 2) {\n            sort(sorted.begin(), sorted.end(), compare_sa);\n            vector<int> tmp(N, 0);\n            REPI(i, 1, N) { tmp[sorted[i]] = tmp[sorted[i - 1]] + compare_sa(sorted[i - 1], sorted[i]); }\n            rank = tmp;\n        }\n        set_lcp();\n    }\n\n    // sizeがTと等しく初めてT以上になるようなSの部分文字列(sortedのイテレータを返す)\n    vector<int>::iterator lower_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sorted[mid], T.size(), T) < 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sorted.begin() + r;\n    }\n\n    // sizeがTと等しく初めてTより大きくなるようなSの部分文字列(sortedのイテレータを返す)\n    vector<int>::iterator upper_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sorted[mid], T.size(), T) <= 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sorted.begin() + r;\n    }\n\n    // S2が部分文字列として何回出現するか\n    int count(string S2) { return upper_bound(S2) - lower_bound(S2); }\n\n    // S[i..], S[j..]が先頭何文字一致しているか\n    int lcp(int i, int j) {\n        assert(0 <= i && 0 <= j && i < N && j < N);\n        if (i == j) return N - i;\n        int l = min(rank[i], rank[j]);\n        int r = max(rank[i], rank[j]);\n        return rmq.query(l, r);\n    }\n};\n",
        "description": "SuffixArrayDoubling"
    },
    "Trie.cpp": {
        "prefix": "Trie",
        "body": "template <char margin = 'A', int char_size = 26>\nstruct Trie {\n    struct TrieNode {\n        array<int, char_size> node;\n        TrieNode() { node.fill(-1); };\n        typename array<int, char_size>::iterator begin() { return node.begin(); }\n        typename array<int, char_size>::iterator end() { return node.end(); }\n        int& operator[](int i) { return node[i]; }\n    };\n    vector<TrieNode> tree;\n    vector<int> num;\n    Trie() : tree(1), num(1) {}\n    void add(string& s) {\n        int t = 0;\n        for (char c : s) {\n            int d = c - margin;\n            if (tree[t][d] == -1) {\n                tree[t][d] = tree.size();\n                tree.emplace_back();\n                num.push_back(0);\n            }\n            t = tree[t][d];\n        }\n        num[t]++;\n    }\n};\n",
        "description": "Trie"
    },
    "ZAlgorithm.cpp": {
        "prefix": "ZAlgorithm",
        "body": "// SとS[i:]の共通prefixの長さの配列を返す、O(|S|)\nvector<int> Z_algorithm(const string& S) {\n    vector<int> A(S.size());\n    A[0] = S.size();\n    int i = 1, j = 0;\n    while (i < S.size()) {\n        while (i + j < S.size() && S[j] == S[i + j]) ++j;\n        A[i] = j;\n        if (j == 0) {\n            ++i;\n            continue;\n        }\n        int k = 1;\n        while (i + k < S.size() && k + A[k] < j) A[i + k] = A[k], ++k;\n        i += k;\n        j -= k;\n    }\n    return A;\n}\n",
        "description": "ZAlgorithm"
    },
    "RollingHash.cpp": {
        "prefix": "RollingHash",
        "body": "using ull = unsigned long long;\ntemplate <class T>\nstruct RollingHash {\n    vector<ull> hash, pows;\n    ull base, mod;\n    RollingHash(const T &a, ull base, ull mod = 1000000009)\n        : hash(a.size() + 1), pows(a.size() + 1, 1), mod(mod), base(base) {\n        for (int i = 0; i < a.size(); i++) {\n            pows[i + 1] = pows[i] * base % mod;\n            hash[i + 1] = hash[i] * base % mod + a[i];\n            if (hash[i + 1] >= mod) hash[i + 1] -= mod;\n        }\n    }\n    // 現在の文字列のサイズ\n    int size() { return hash.size() - 1; }\n    // [l, r)\n    ull get(int l, int r) {\n        assert(l <= r);\n        ull ret = hash[r] + mod - hash[l] * pows[r - l] % mod;\n        if (ret >= mod) ret -= mod;\n        return ret;\n    }\n    void concat(const T &b) {\n        int n = hash.size() - 1, m = b.size();\n        pows.resize(n + m + 1);\n        hash.resize(n + m + 1);\n        for (int i = 0; i < m; i++) {\n            pows[n + i + 1] = pows[n + i] * base % mod;\n            hash[n + i + 1] = hash[n + i] * base % mod + b[i];\n            if (hash[n + i + 1] >= mod) hash[n + i + 1] -= mod;\n        }\n    }\n    void pop_back() {\n        hash.pop_back();\n        pows.pop_back();\n    }\n};\n\nconstexpr int HASH_NUM = 4;\nstruct bases_t {\n    int use[HASH_NUM];\n    int &operator[](int i) { return use[i]; }\n    bases_t() {\n        mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n        for (int i = 0; i < HASH_NUM; i++) use[i] = rnd() % 10000;\n    }\n} bases;\n\nusing multihash_t = array<int, HASH_NUM>;\ntemplate <class T = vector<int>>\nstruct MultiRollingHash {\n    vector<RollingHash<T>> rhs;\n    MultiRollingHash(const T &a) {\n        for (int i = 0; i < HASH_NUM; i++) {\n            rhs.push_back(RollingHash<T>(a, bases[i]));\n        }\n    }\n    multihash_t get(int l, int r) {\n        multihash_t ret;\n        for (int i = 0; i < HASH_NUM; i++) ret[i] = rhs[i].get(l, r);\n        return ret;\n    }\n    int size() { return rhs[0].size(); }\n    void concat(const T &b) {\n        for (auto &rh : rhs) rh.concat(b);\n    }\n    void pop_back() {\n        for (auto &rh : rhs) rh.pop_back();\n    }\n};\n",
        "description": "RollingHash"
    },
    "MultisetHash.cpp": {
        "prefix": "MultisetHash",
        "body": "using ull = unsigned long long;\nrandom_device rnd;\nmt19937 mt(rnd());\nmt19937_64 mt64(rnd());\nint mod_pow(int x, int n, int mod) {\n    if (n <= 0) return 1;\n    int tmp = mod_pow(x, n / 2, mod);\n    return tmp * tmp % mod * (n % 2 ? x : 1) % mod;\n}\n// Miller-Rabin\nbool is_prime(int n, int times = 50) {\n    if (n == 2) return true;\n    if (n % 2 == 0 || n < 2) return false;\n    int d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    while (times--) {\n        int a = rnd() % (n - 2) + 1;\n        int t = d;\n        int y = mod_pow(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t *= 2;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint gen_prime() {\n    int cnt = 0;\n    while (1) {\n        int n = mt();\n        n != 1;\n        if (is_prime(n)) return n;\n    }\n}\nclass MultisetHash {\npublic:\n    vector<ull> hash, pows;\n    ull mod;\n    int to_int(char c) { return c - 'a'; }\n    MultisetHash() {}\n    MultisetHash(const string& S, int k = 26, ull base = gen_prime(), ull m = gen_prime())\n        : hash(S.size() + 1), pows(k), mod(m) {\n        pows[0] = 1;\n        for (int i = 0; i < k - 1; i++) {\n            pows[i + 1] = pows[i] * base % mod;\n        }\n        for (int i = 0; i < S.size(); i++) {\n            hash[i + 1] = hash[i] + pows[to_int(S[i])];\n        }\n    }\n    // [l, r)\n    ull get(int l, int r) {\n        int ret = hash[r] + mod - hash[l];\n        if (ret >= mod) ret -= mod;\n        return ret;\n    }\n};\n",
        "description": "MultisetHash"
    },
    "LongestCommonPrefix.cpp": {
        "prefix": "LongestCommonPrefix",
        "body": "template <class T = int>\nclass SegTree {\n    using VT = vector<T>;\n    int orig_n;\n    // k番目のノードの[l, r)について[a, b)を求める\n    T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) {\n            return UNIT;\n        }\n        if (a <= l && r <= b) {\n            return dat[k];\n        }\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\npublic:\n    int N;\n    VT dat;\n    function<T(T, T)> f;\n    int UNIT;\n    SegTree(int n, function<T(T, T)> f_, const T unit) {\n        orig_n = n;\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < n; N *= 2)\n            ;\n        dat = VT(2 * N - 1, UNIT);\n    }\n    SegTree(\n        VT a = {}, function<T(T, T)> f_ = [](int a, int b) { return min(a, b); }, T unit = 1e15) {\n        orig_n = a.size();\n        f = f_;\n        UNIT = unit;\n        for (N = 1; N < a.size(); N *= 2)\n            ;\n        dat = VT(2 * N - 1);\n        REP(i, a.size()) { dat[N - 1 + i] = a[i]; }\n        for (int k = N - 2; k >= 0; k--) {\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // k番目をaに\n    void update(int k, int a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // [a, b)でのクエリ\n    T query(int a, int b) {\n        assert(0 <= a && a < b && b <= orig_n);\n        return query(a, b, 0, 0, N);\n    }\n};\n\n// SA-ISによるSuffix Arrayの実装。構築O(N)\nclass SuffixArray {\n    vector<int> sa_is(const vector<int>& str, const int k) {\n        const int n = str.size();\n        vector<bool> is_S(n);\n        is_S[n - 1] = true;\n        vector<bool> is_LMS(n);\n        vector<int> LMSs;\n        for (int i = n - 2; i >= 0; i--) {\n            is_S[i] = str[i] < str[i + 1] || (str[i] == str[i + 1] && is_S[i + 1]);\n        }\n        REP(i, n) {\n            if (is_S[i] & (i == 0 || !is_S[i - 1])) {\n                is_LMS[i] = true;\n                LMSs.push_back(i);\n            }\n        }\n        vector<int> pseudo_sa = induced_sort(str, LMSs, is_S, k);\n        vector<int> orderedLMSs(LMSs.size());\n        int index = 0;\n        for (int x : pseudo_sa) {\n            if (is_LMS[x]) {\n                orderedLMSs[index++] = x;\n            }\n        }\n        pseudo_sa[orderedLMSs[0]] = 0;\n        int rank = 0;\n        if (orderedLMSs.size() > 1) {\n            pseudo_sa[orderedLMSs[1]] = ++rank;\n        }\n        REPI(i, 1, orderedLMSs.size() - 1) {\n            bool is_diff = false;\n            REP(j, n) {\n                int p = orderedLMSs[i] + j;\n                int q = orderedLMSs[i + 1] + j;\n                if (str[p] != str[q] || is_LMS[p] != is_LMS[q]) {\n                    is_diff = true;\n                    break;\n                }\n                if (j > 0 && is_LMS[p]) {\n                    break;\n                }\n            }\n            pseudo_sa[orderedLMSs[i + 1]] = is_diff ? ++rank : rank;\n        }\n        vector<int> new_str(LMSs.size());\n        index = 0;\n        REP(i, n) {\n            if (is_LMS[i]) {\n                new_str[index++] = pseudo_sa[i];\n            }\n        }\n        vector<int> LMS_sa;\n        if (rank + 1 == LMSs.size()) {\n            LMS_sa = orderedLMSs;\n        } else {\n            LMS_sa = sa_is(new_str, rank + 1);\n            for (int& x : LMS_sa) {\n                x = LMSs[x];\n            }\n        }\n        return induced_sort(str, LMS_sa, is_S, k);\n    }\n\n    vector<int> induced_sort(const vector<int>& str, const vector<int>& LMSs, const vector<bool>& is_S, const int k) {\n        int n = str.size();\n        vector<int> buckets(n);\n        vector<int> chars(k + 1);\n        for (int c : str) {\n            chars[c + 1]++;\n        }\n        REP(i, k) { chars[i + 1] += chars[i]; }\n        vector<int> count(k);\n        for (int i = LMSs.size() - 1; i >= 0; i--) {\n            int c = str[LMSs[i]];\n            buckets[chars[c + 1] - 1 - count[c]++] = LMSs[i];\n        }\n        count = vector<int>(k);\n        REP(i, n) {\n            if (buckets[i] == 0 || is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c] + count[c]++] = buckets[i] - 1;\n        }\n        count = vector<int>(k);\n        for (int i = n - 1; i >= 0; i--) {\n            if (buckets[i] == 0 || !is_S[buckets[i] - 1]) {\n                continue;\n            }\n            int c = str[buckets[i] - 1];\n            buckets[chars[c + 1] - 1 - count[c]++] = buckets[i] - 1;\n        }\n        return buckets;\n    }\n\npublic:\n    string S;\n    int N;\n    vector<int> sa;  // sa[i]: suffixが辞書順i番目となる開始位置のindex\n    SuffixArray(string str_in) : S(str_in), N(str_in.size()) {\n        str_in += \"$\";\n        vector<int> str(N + 1);\n        REP(i, N + 1) { str[i] = str_in[i] - '$'; }\n        sa = sa_is(str, 128);\n        sa.erase(sa.begin());\n    }\n    int operator[](int index) { return sa[index]; }\n\n    // sizeがTと等しく初めてT以上になるようなSの部分文字列(sa)\n    vector<int>::iterator lower_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) < 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // sizeがTと等しく初めてTより大きくなるようなSの部分文字列(sa)\n    vector<int>::iterator upper_bound(string T) {\n        int l = -1, r = N;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (S.compare(sa[mid], T.size(), T) <= 0) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        return sa.begin() + r;\n    }\n\n    // S2が部分文字列として何回出現するか\n    int count(string S2) { return upper_bound(S2) - lower_bound(S2); }\n};\n\nclass LongestCommonPrefix {\n    SegTree<> rmq;\n    vector<int> lcp;  // lcp[i]: S[sa[i]..]とS[sa[i + 1]..]が先頭何文字一致しているか、lcp[N - 1] = 0\n    vector<int> lcp_begin;  // lcp_begin[i]: S[0..]とS[i]が先頭何文字一致しているか\npublic:\n    const string S;\n    int N;\n    vector<int> sa;\n    vector<int> rank;  // rank[i]: iから始まるsuffixの辞書順での順位\n    LongestCommonPrefix();\n    LongestCommonPrefix(const string& str) : S(str), N(str.size()), rank(str.size()), lcp(str.size()) {\n        sa = SuffixArray(str).sa;\n        // rankの設定\n        REP(i, N) { rank[sa[i]] = i; }\n        // S[i]を順番に見ていきS[i - 1] -　1文字以上が共通することを利用してしゃくとり\n        lcp = vector<int>(N);\n        int h = 0;\n        REP(i, N) {\n            if (h > 0) h--;\n            if (rank[i] == N - 1) continue;\n            int j = sa[rank[i] + 1];  // 比べる対象(辞書順が一つ大きいもの)\n            for (; i + h < N && j + h < N; h++) {\n                if (S[i + h] != S[j + h]) break;\n            }\n            lcp[rank[i]] = h;\n        }\n        // 必要に応じてコメントアウト\n        set_query1();\n        set_query2();\n    }\n    int operator[](int index) { return lcp[index]; }\n\n    // S[i..], S[j..]が先頭何文字一致しているか\n    int query(int i, int j) {\n        assert(0 <= i && 0 <= j && i < N && j < N);\n        if (i == j) return N - i;\n        int l = min(rank[i], rank[j]);\n        int r = max(rank[i], rank[j]);\n        return rmq.query(l, r);\n    }\n    void set_query2() {\n        // S[i..], S[j..]のlcpが求められるようにRMQ上にのせる\n        rmq = SegTree<int>(\n            lcp, [](int a, int b) { return min(a, b); }, 1e15);\n    }\n\n    // S[i..]がS[0..]と先頭文字一致しているか\n    int query(int i) { return lcp_begin[i]; }\n    void set_query1() {\n        lcp_begin = vector<int>(N);\n        lcp_begin[0] = N;\n        for (int i = rank[0] - 1; i >= 0; i--) {\n            lcp_begin[sa[i]] = min(lcp_begin[sa[i + 1]], lcp[i]);\n        }\n        for (int i = rank[0] + 1; i < N; i++) {\n            lcp_begin[sa[i]] = min(lcp_begin[sa[i - 1]], lcp[i - 1]);\n        }\n    }\n};\n",
        "description": "LongestCommonPrefix"
    },
    "LongestCommonSubsequence.cpp": {
        "prefix": "LongestCommonSubsequence",
        "body": "// Longest Common Subsequence: O(nm)\nvector<vector<int>> LCS(const vector<int>& s, const vector<int>& t) {\n    int n = s.size(), m = t.size();\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i + 1][j + 1] = s[i] == t[j] ? dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]);\n        }\n    }\n    return dp;\n}\n// メモリ節約\nvector<vector<int>> LCS2(const vector<int>& s, const vector<int>& t) {\n    int n = s.size(), m = t.size();\n    vector<vector<int>> dp(2, vector<int>(m + 1));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[1][j + 1] = s[i] == t[j] ? dp[0][j] + 1 : max(dp[0][j + 1], dp[1][j]);\n        }\n        swap(dp[0], dp[1]);\n    }\n    return dp;\n}\n",
        "description": "LongestCommonSubsequence"
    },
    "Geometry.cpp": {
        "prefix": "Geometry",
        "body": "const double EPS = 1e-8;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n// 点、ベクトル\nusing P = complex<double>;\nconst P DUM = {INF + 12345, INF + 67890};\nnamespace std {\nbool operator<(const P& a, const P& b) { return a.X != b.X ? a.X < b.X : a.Y < b.Y; }\n}  // namespace std\ndouble dot(const P& a, const P& b) { return a.X * b.X + a.Y * b.Y; }\ndouble cross(const P& a, const P& b) { return a.X * b.Y - a.Y * b.X; }\ndouble manhattan(const P& a, const P& b) { return abs(a.X - b.X) + abs(a.Y - b.Y); }\n\n// 直線 ax + by + c = 0;\nstruct Line {\n    double a, b, c;\n    Line(double a, double b, double c) : a(a), b(b), c(c) {}\n};\nbool parallel(const Line& l1, const Line& l2) { return EQ(l1.a * l2.b, l1.b * l2.a); }\nP intersection(const Line& l1, const Line& l2) {\n    if (parallel(l1, l2)) return DUM;\n    P vec = {l1.b * l2.c - l2.b * l1.c, l2.a * l1.c - l1.a * l2.c};\n    return vec / (l1.a * l2.b - l1.b * l2.a);\n}\n\n// 線分\nstruct Segment {\n    P p1, p2;\n    Segment(const P& p1, const P& p2) : p1(p1), p2(p2) {}\n    double len() const { return abs(p2 - p1); }\n    bool between(P p) const { return (p1.X - p.X) * (p2.X - p.X) < EPS && (p1.Y - p.Y) * (p2.Y - p.Y) < EPS; }\n    Line to_line() const {\n        P v = p2 - p1;\n        return Line(v.Y, v.X, -(v.Y * p1.X + v.X * p1.Y));\n    }\n};\n// 線分と点の距離\ndouble dist(const Segment& s, const P& p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < EPS) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < EPS) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)) / s.len();\n}\n\n// 直線と線分の交点\nP intersection(const Line& l1, const Segment& s) {\n    Line l2 = s.to_line();\n    P p = intersection(l1, l2);\n    if (!s.between(p)) return DUM;\n    return p;\n}\n\n// 円\nstruct Circle {\n    P p;\n    double r;\n    Circle(const P& p, double r) : p(p), r(r) {}\n};\n",
        "description": "Geometry"
    },
    "FordFulkerson.cpp": {
        "prefix": "FordFulkerson",
        "body": "// Ford Fulkerson法 O(F * E)\nclass Graph {\n    vector<bool> used;\n    int t;  // ゴール\n    // f: 流量\n    int dfs(int v, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (edge& e : G[v]) {\n            if (used[e.to] || e.cap <= 0) continue;\n            int res = dfs(e.to, min(f, e.cap));\n            if (res <= 0) continue;\n            e.cap -= res;\n            G[e.to][e.rev].cap += res;\n            return res;\n        }\n        return 0;\n    }\n\npublic:\n    int V;\n    // G[e.to][e.rev]で逆辺にアクセスできるように\n    // 逆辺のcapは、\"正辺に流れている流量\"(その分だけ逆に戻せるので)(はじめは全て0)\n    struct edge {\n        int to, cap, rev;\n    };\n    vector<vector<edge>> G;\n    Graph(int V) : V(V), G(V), used(V) {}\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back({to, cap, (int)G[to].size()});\n        G[to].push_back({from, 0, (int)G[from].size() - 1});\n    }\n    int max_flow(int s, int t) {\n        this->t = t;\n        int ret = 0;\n        while (1) {\n            fill(ALL(used), false);\n            int f = dfs(s, 1e18);\n            if (f == 0) return ret;\n            ret += f;\n        }\n    }\n};\n",
        "description": "FordFulkerson"
    },
    "Dinic.cpp": {
        "prefix": "Dinic",
        "body": "// Dinic法 O(E * V^2)\nclass Graph {\n    int t;  // ゴール\n    vector<int> level, iter;\n    void bfs(int s) {\n        for (int i = 0; i < level.size(); i++) level[i] = -1;\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    int V;\n    struct edge {\n        int to, cap, rev;\n    };\n    vector<vector<edge>> G;\n    Graph(int V) : V(V), G(V), level(V), iter(V) {}\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(edge{to, cap, (int)G[to].size()});\n        G[to].push_back(edge{from, 0, (int)G[from].size() - 1});\n    }\n\n    int max_flow(int s, int t) {\n        int flow = 0;\n        this->t = t;\n        while (1) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            for (int i = 0; i < iter.size(); i++) iter[i] = 0;\n            int f;\n            while ((f = dfs(s, (1LL << 60))) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n",
        "description": "Dinic"
    }
}